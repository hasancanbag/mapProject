{"ast":null,"code":"/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { SnapEvent, SnapEventType } from '../events/SnapEvent.js';\nimport { boundingExtent, buffer, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, squaredDistance } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate, toUserExtent } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { listen, unlistenByKey } from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n * @property {import(\"../Feature.js\").default|null} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>|null} segment Segment, or `null` if snapped to a vertex.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n * @return {import(\"../Feature.js\").default|null} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (/** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature;\n  }\n  if (/** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */evt.element) {\n    return /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */evt.element;\n  }\n  return null;\n}\nconst tempSegment = [];\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'snap', SnapEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'snap', Return>} SnapOnSignature\n */\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that uses them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap.js';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @fires SnapEvent\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */\n    options;\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    super(pointerOptions);\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SnapOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGeometry_.bind(this),\n      'LineString': this.segmentLineStringGeometry_.bind(this),\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\n      'Circle': this.segmentCircleGeometry_.bind(this)\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [register] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, register) {\n    register = register !== undefined ? register : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        const segments = /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */[];\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0]\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map(s => boundingExtent(s));\n          const segmentsData = segments.map(segment => ({\n            feature: feature,\n            segment: segment\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   * @override\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n      this.dispatchEvent(new SnapEvent(SnapEventType.SNAP, {\n        vertex: evt.coordinate,\n        vertexPixel: evt.pixel,\n        feature: result.feature,\n        segment: result.segment\n      }));\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.addFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.removeFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */evt.target;\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = Object.values(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, unlisten) {\n    const unregister = unlisten !== undefined ? unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   * @override\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */\n    this.getFeatures_();\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      this.rBush_.clear();\n      Object.values(this.featureChangeListenerKeys_).forEach(unlistenByKey);\n      this.featureChangeListenerKeys_ = {};\n    }\n    super.setMap(map);\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n      features.forEach(feature => this.addFeature(feature));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../Map.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n    const box = toUserExtent(buffer(boundingExtent([projectedCoordinate]), map.getView().getResolution() * this.pixelTolerance_), projection);\n    const segments = this.rBush_.getInExtent(box);\n    const segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n    let closestFeature;\n    let closestSegment = null;\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])],\n            feature: closestFeature,\n            segment: closestSegment\n          };\n        }\n      }\n      return null;\n    };\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach(vertex => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n              closestFeature = segmentData.feature;\n            }\n          });\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry.clone().transform(userProjection, projection);\n          }\n          vertex = closestOnCircle(projectedCoordinate, /** @type {import(\"../geom/Circle.js\").default} */circleGeometry);\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment;\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = toUserCoordinate(vertex, projection);\n            closestSegment = segmentData.feature.getGeometry().getType() === 'Circle' ? null : segmentData.segment;\n            minSquaredDistance = delta;\n            closestFeature = segmentData.feature;\n          }\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentCircleGeometry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = circleGeometry.clone().transform(userProjection, projection);\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentGeometryCollectionGeometry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentLineStringGeometry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiLineStringGeometry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPointGeometry_(segments, geometry) {\n    geometry.getCoordinates().forEach(point => {\n      segments.push([point]);\n    });\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPolygonGeometry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPointGeometry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPolygonGeometry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n}\nexport default Snap;","map":{"version":3,"names":["CollectionEventType","EventType","PointerInteraction","RBush","VectorEventType","FALSE","TRUE","SnapEvent","SnapEventType","boundingExtent","buffer","createEmpty","closestOnCircle","closestOnSegment","squaredDistance","fromCircle","fromUserCoordinate","getUserProjection","toUserCoordinate","toUserExtent","getUid","listen","unlistenByKey","getFeatureFromEvent","evt","feature","element","tempSegment","Snap","constructor","options","pointerOptions","handleDownEvent","stopDown","on","once","un","source_","source","vertex_","vertex","undefined","edge_","edge","features_","features","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","pixelTolerance_","pixelTolerance","rBush_","GEOMETRY_SEGMENTERS_","segmentPointGeometry_","bind","segmentLineStringGeometry_","segmentPolygonGeometry_","segmentMultiPointGeometry_","segmentMultiLineStringGeometry_","segmentMultiPolygonGeometry_","segmentGeometryCollectionGeometry_","segmentCircleGeometry_","addFeature","register","feature_uid","geometry","getGeometry","segmenter","getType","getExtent","segments","length","insert","segment","extents","map","s","segmentsData","load","CHANGE","handleFeatureChange_","getFeatures_","getFeatures","handleEvent","result","snapTo","pixel","coordinate","slice","vertexPixel","dispatchEvent","SNAP","handleFeatureAdd_","handleFeatureRemove_","removeFeature","target","handlingDownUpSequence","uid","updateFeature_","handleUpEvent","featuresToUpdate","Object","values","forEach","unlisten","unregister","extent","rBush","nodesToRemove","forEachInExtent","node","push","i","remove","setMap","currentMap","getMap","keys","clear","ADD","REMOVE","ADDFEATURE","REMOVEFEATURE","pixelCoordinate","projection","getView","getProjection","projectedCoordinate","box","getResolution","getInExtent","segmentsLength","closestVertex","minSquaredDistance","Infinity","closestFeature","closestSegment","squaredPixelTolerance","getResult","getPixelFromCoordinate","squaredPixelDistance","Math","round","segmentData","tempVertexCoord","delta","circleGeometry","userProjection","clone","transform","segmentStart","segmentEnd","polygon","coordinates","getCoordinates","ii","geometries","getGeometriesArray","lines","j","jj","point","polygons","k","kk","rings"],"sources":["C:/Users/hasan/webproj/openlayers-project/node_modules/ol/interaction/Snap.js"],"sourcesContent":["/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {SnapEvent, SnapEventType} from '../events/SnapEvent.js';\nimport {boundingExtent, buffer, createEmpty} from '../extent.js';\nimport {\n  closestOnCircle,\n  closestOnSegment,\n  squaredDistance,\n} from '../coordinate.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n * @property {import(\"../Feature.js\").default|null} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>|null} segment Segment, or `null` if snapped to a vertex.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n * @return {import(\"../Feature.js\").default|null} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\n  ) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n      .feature;\n  }\n  if (\n    /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element\n  ) {\n    return /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element;\n  }\n  return null;\n}\n\nconst tempSegment = [];\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'snap', SnapEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'snap', Return>} SnapOnSignature\n */\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that uses them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap.js';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @fires SnapEvent\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SnapOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGeometry_.bind(this),\n      'LineString': this.segmentLineStringGeometry_.bind(this),\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\n      'Circle': this.segmentCircleGeometry_.bind(this),\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [register] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, register) {\n    register = register !== undefined ? register : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] =\n          geometry.getExtent(createEmpty());\n        const segments =\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0],\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map((s) => boundingExtent(s));\n          const segmentsData = segments.map((segment) => ({\n            feature: feature,\n            segment: segment,\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_,\n        this,\n      );\n    }\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   * @override\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n      this.dispatchEvent(\n        new SnapEvent(SnapEventType.SNAP, {\n          vertex: evt.coordinate,\n          vertexPixel: evt.pixel,\n          feature: result.feature,\n          segment: result.segment,\n        }),\n      );\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.addFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.removeFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = Object.values(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, unlisten) {\n    const unregister = unlisten !== undefined ? unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   * @override\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (\n      this.getFeatures_()\n    );\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      this.rBush_.clear();\n      Object.values(this.featureChangeListenerKeys_).forEach(unlistenByKey);\n      this.featureChangeListenerKeys_ = {};\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(\n            this.features_,\n            CollectionEventType.ADD,\n            this.handleFeatureAdd_,\n            this,\n          ),\n          listen(\n            this.features_,\n            CollectionEventType.REMOVE,\n            this.handleFeatureRemove_,\n            this,\n          ),\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(\n            this.source_,\n            VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_,\n            this,\n          ),\n          listen(\n            this.source_,\n            VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_,\n            this,\n          ),\n        );\n      }\n      features.forEach((feature) => this.addFeature(feature));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../Map.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n\n    const box = toUserExtent(\n      buffer(\n        boundingExtent([projectedCoordinate]),\n        map.getView().getResolution() * this.pixelTolerance_,\n      ),\n      projection,\n    );\n\n    const segments = this.rBush_.getInExtent(box);\n    const segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n    let closestFeature;\n    let closestSegment = null;\n\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [\n              Math.round(vertexPixel[0]),\n              Math.round(vertexPixel[1]),\n            ],\n            feature: closestFeature,\n            segment: closestSegment,\n          };\n        }\n      }\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach((vertex) => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n              closestFeature = segmentData.feature;\n            }\n          });\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry\n              .clone()\n              .transform(userProjection, projection);\n          }\n          vertex = closestOnCircle(\n            projectedCoordinate,\n            /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry),\n          );\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment;\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = toUserCoordinate(vertex, projection);\n            closestSegment =\n              segmentData.feature.getGeometry().getType() === 'Circle'\n                ? null\n                : segmentData.segment;\n            minSquaredDistance = delta;\n            closestFeature = segmentData.feature;\n          }\n        }\n      }\n\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentCircleGeometry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = circleGeometry\n        .clone()\n        .transform(userProjection, projection);\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentGeometryCollectionGeometry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentLineStringGeometry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiLineStringGeometry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPointGeometry_(segments, geometry) {\n    geometry.getCoordinates().forEach((point) => {\n      segments.push([point]);\n    });\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPolygonGeometry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPointGeometry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPolygonGeometry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n}\n\nexport default Snap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}