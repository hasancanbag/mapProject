{"ast":null,"code":"/**\n * @module ol/interaction/Translate\n */\nimport Collection from '../Collection.js';\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport InteractionProperty from './Property.js';\nimport PointerInteraction from './Pointer.js';\nimport { TRUE } from '../functions.js';\nimport { always } from '../events/condition.js';\nimport { fromUserCoordinate, getUserProjection } from '../proj.js';\n\n/**\n * @enum {string}\n */\nconst TranslateEventType = {\n  /**\n   * Triggered upon feature translation start.\n   * @event TranslateEvent#translatestart\n   * @api\n   */\n  TRANSLATESTART: 'translatestart',\n  /**\n   * Triggered upon feature translation.\n   * @event TranslateEvent#translating\n   * @api\n   */\n  TRANSLATING: 'translating',\n  /**\n   * Triggered upon feature translation end.\n   * @event TranslateEvent#translateend\n   * @api\n   */\n  TRANSLATEEND: 'translateend'\n};\n\n/**\n * A function that takes a {@link module:ol/Feature~Feature} or\n * {@link module:ol/render/Feature~RenderFeature} and a\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise.\n * @typedef {function(Feature, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.always}.\n * @property {Collection<Feature>} [features] Features contained in this collection will be able to be translated together.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers] A list of layers from which features should be\n * translated. Alternatively, a filter function can be provided. The\n * function will be called for each layer in the map and should return\n * `true` for layers that you want to be translatable. If the option is\n * absent, all visible layers will be considered translatable.\n * Not used if `features` is provided.\n * @property {FilterFunction} [filter] A function\n * that takes a {@link module:ol/Feature~Feature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise. Not used if `features` is provided.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\n * will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\n * are instances of this type.\n */\nexport class TranslateEvent extends Event {\n  /**\n   * @param {TranslateEventType} type Type.\n   * @param {Collection<Feature>} features The features translated.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} startCoordinate The original coordinates before.translation started\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   */\n  constructor(type, features, coordinate, startCoordinate, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The features being translated.\n     * @type {Collection<Feature>}\n     * @api\n     */\n    this.features = features;\n\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n\n    /**\n     * The coordinate of the start position before translation started.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.startCoordinate = startCoordinate;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for translating (moving) features.\n * If you want to translate multiple features in a single action (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.\n *\n * @fires TranslateEvent\n * @api\n */\nclass Translate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super(/** @type {import(\"./Pointer.js\").Options} */options);\n\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TranslateOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * The last position we translated to.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.lastCoordinate_ = null;\n\n    /**\n     * The start position before translation started.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.startCoordinate_ = null;\n\n    /**\n     * @type {Collection<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features !== undefined ? options.features : null;\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers && !this.features_) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter && !this.features_ ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : always;\n\n    /**\n     * @type {Feature}\n     * @private\n     */\n    this.lastFeature_ = null;\n    this.addChangeListener(InteractionProperty.ACTIVE, this.handleActiveChanged_);\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleDownEvent(event) {\n    if (!event.originalEvent || !this.condition_(event)) {\n      return false;\n    }\n    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\n    if (!this.lastCoordinate_ && this.lastFeature_) {\n      this.startCoordinate_ = event.coordinate;\n      this.lastCoordinate_ = event.coordinate;\n      this.handleMoveEvent(event);\n      const features = this.features_ || new Collection([this.lastFeature_]);\n      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATESTART, features, event.coordinate, this.startCoordinate_, event));\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(event) {\n    if (this.lastCoordinate_) {\n      this.lastCoordinate_ = null;\n      this.handleMoveEvent(event);\n      const features = this.features_ || new Collection([this.lastFeature_]);\n      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATEEND, features, event.coordinate, this.startCoordinate_, event));\n      // cleanup\n      this.startCoordinate_ = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @override\n   */\n  handleDragEvent(event) {\n    if (this.lastCoordinate_) {\n      const newCoordinate = event.coordinate;\n      const projection = event.map.getView().getProjection();\n      const newViewCoordinate = fromUserCoordinate(newCoordinate, projection);\n      const lastViewCoordinate = fromUserCoordinate(this.lastCoordinate_, projection);\n      const deltaX = newViewCoordinate[0] - lastViewCoordinate[0];\n      const deltaY = newViewCoordinate[1] - lastViewCoordinate[1];\n      const features = this.features_ || new Collection([this.lastFeature_]);\n      const userProjection = getUserProjection();\n      features.forEach(function (feature) {\n        const geom = feature.getGeometry();\n        if (userProjection) {\n          geom.transform(userProjection, projection);\n          geom.translate(deltaX, deltaY);\n          geom.transform(projection, userProjection);\n        } else {\n          geom.translate(deltaX, deltaY);\n        }\n        feature.setGeometry(geom);\n      });\n      this.lastCoordinate_ = newCoordinate;\n      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATING, features, newCoordinate, this.startCoordinate_, event));\n    }\n  }\n\n  /**\n   * Handle pointer move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @override\n   */\n  handleMoveEvent(event) {\n    const elem = event.map.getViewport();\n\n    // Change the cursor to grab/grabbing if hovering any of the features managed\n    // by the interaction\n    if (this.featuresAtPixel_(event.pixel, event.map)) {\n      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\n      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\n    } else {\n      elem.classList.remove('ol-grab', 'ol-grabbing');\n    }\n  }\n\n  /**\n   * Tests to see if the given coordinates intersects any of our selected\n   * features.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel coordinate to test for intersection.\n   * @param {import(\"../Map.js\").default} map Map to test the intersection on.\n   * @return {Feature} Returns the feature found at the specified pixel\n   * coordinates.\n   * @private\n   */\n  featuresAtPixel_(pixel, map) {\n    return map.forEachFeatureAtPixel(pixel, (feature, layer) => {\n      if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n        return undefined;\n      }\n      if (this.features_ && !this.features_.getArray().includes(feature)) {\n        return undefined;\n      }\n      return feature;\n    }, {\n      layerFilter: this.layerFilter_,\n      hitTolerance: this.hitTolerance_\n    });\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   * @override\n   */\n  setMap(map) {\n    const oldMap = this.getMap();\n    super.setMap(map);\n    this.updateState_(oldMap);\n  }\n\n  /**\n   * @private\n   */\n  handleActiveChanged_() {\n    this.updateState_(null);\n  }\n\n  /**\n   * @param {import(\"../Map.js\").default} oldMap Old map.\n   * @private\n   */\n  updateState_(oldMap) {\n    let map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      map = map || oldMap;\n      if (map) {\n        const elem = map.getViewport();\n        elem.classList.remove('ol-grab', 'ol-grabbing');\n      }\n    }\n  }\n}\nexport default Translate;","map":{"version":3,"names":["Collection","Event","Feature","InteractionProperty","PointerInteraction","TRUE","always","fromUserCoordinate","getUserProjection","TranslateEventType","TRANSLATESTART","TRANSLATING","TRANSLATEEND","TranslateEvent","constructor","type","features","coordinate","startCoordinate","mapBrowserEvent","Translate","options","on","once","un","lastCoordinate_","startCoordinate_","features_","undefined","layerFilter","layers","layer","includes","layerFilter_","filter_","filter","hitTolerance_","hitTolerance","condition_","condition","lastFeature_","addChangeListener","ACTIVE","handleActiveChanged_","handleDownEvent","event","originalEvent","featuresAtPixel_","pixel","map","handleMoveEvent","dispatchEvent","handleUpEvent","handleDragEvent","newCoordinate","projection","getView","getProjection","newViewCoordinate","lastViewCoordinate","deltaX","deltaY","userProjection","forEach","feature","geom","getGeometry","transform","translate","setGeometry","elem","getViewport","classList","remove","add","forEachFeatureAtPixel","getArray","getHitTolerance","setHitTolerance","setMap","oldMap","getMap","updateState_","active","getActive"],"sources":["C:/Users/hasan/webproj/openlayers-project/node_modules/ol/interaction/Translate.js"],"sourcesContent":["/**\n * @module ol/interaction/Translate\n */\nimport Collection from '../Collection.js';\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport InteractionProperty from './Property.js';\nimport PointerInteraction from './Pointer.js';\nimport {TRUE} from '../functions.js';\nimport {always} from '../events/condition.js';\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\n\n/**\n * @enum {string}\n */\nconst TranslateEventType = {\n  /**\n   * Triggered upon feature translation start.\n   * @event TranslateEvent#translatestart\n   * @api\n   */\n  TRANSLATESTART: 'translatestart',\n  /**\n   * Triggered upon feature translation.\n   * @event TranslateEvent#translating\n   * @api\n   */\n  TRANSLATING: 'translating',\n  /**\n   * Triggered upon feature translation end.\n   * @event TranslateEvent#translateend\n   * @api\n   */\n  TRANSLATEEND: 'translateend',\n};\n\n/**\n * A function that takes a {@link module:ol/Feature~Feature} or\n * {@link module:ol/render/Feature~RenderFeature} and a\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise.\n * @typedef {function(Feature, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.always}.\n * @property {Collection<Feature>} [features] Features contained in this collection will be able to be translated together.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers] A list of layers from which features should be\n * translated. Alternatively, a filter function can be provided. The\n * function will be called for each layer in the map and should return\n * `true` for layers that you want to be translatable. If the option is\n * absent, all visible layers will be considered translatable.\n * Not used if `features` is provided.\n * @property {FilterFunction} [filter] A function\n * that takes a {@link module:ol/Feature~Feature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise. Not used if `features` is provided.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\n * will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\n * are instances of this type.\n */\nexport class TranslateEvent extends Event {\n  /**\n   * @param {TranslateEventType} type Type.\n   * @param {Collection<Feature>} features The features translated.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} startCoordinate The original coordinates before.translation started\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   */\n  constructor(type, features, coordinate, startCoordinate, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The features being translated.\n     * @type {Collection<Feature>}\n     * @api\n     */\n    this.features = features;\n\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n\n    /**\n     * The coordinate of the start position before translation started.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.startCoordinate = startCoordinate;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for translating (moving) features.\n * If you want to translate multiple features in a single action (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.\n *\n * @fires TranslateEvent\n * @api\n */\nclass Translate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TranslateOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * The last position we translated to.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.lastCoordinate_ = null;\n\n    /**\n     * The start position before translation started.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.startCoordinate_ = null;\n\n    /**\n     * @type {Collection<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features !== undefined ? options.features : null;\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers && !this.features_) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter && !this.features_ ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : always;\n\n    /**\n     * @type {Feature}\n     * @private\n     */\n    this.lastFeature_ = null;\n\n    this.addChangeListener(\n      InteractionProperty.ACTIVE,\n      this.handleActiveChanged_,\n    );\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleDownEvent(event) {\n    if (!event.originalEvent || !this.condition_(event)) {\n      return false;\n    }\n    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\n    if (!this.lastCoordinate_ && this.lastFeature_) {\n      this.startCoordinate_ = event.coordinate;\n      this.lastCoordinate_ = event.coordinate;\n      this.handleMoveEvent(event);\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATESTART,\n          features,\n          event.coordinate,\n          this.startCoordinate_,\n          event,\n        ),\n      );\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   * @override\n   */\n  handleUpEvent(event) {\n    if (this.lastCoordinate_) {\n      this.lastCoordinate_ = null;\n      this.handleMoveEvent(event);\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATEEND,\n          features,\n          event.coordinate,\n          this.startCoordinate_,\n          event,\n        ),\n      );\n      // cleanup\n      this.startCoordinate_ = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @override\n   */\n  handleDragEvent(event) {\n    if (this.lastCoordinate_) {\n      const newCoordinate = event.coordinate;\n      const projection = event.map.getView().getProjection();\n\n      const newViewCoordinate = fromUserCoordinate(newCoordinate, projection);\n      const lastViewCoordinate = fromUserCoordinate(\n        this.lastCoordinate_,\n        projection,\n      );\n      const deltaX = newViewCoordinate[0] - lastViewCoordinate[0];\n      const deltaY = newViewCoordinate[1] - lastViewCoordinate[1];\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n      const userProjection = getUserProjection();\n\n      features.forEach(function (feature) {\n        const geom = feature.getGeometry();\n        if (userProjection) {\n          geom.transform(userProjection, projection);\n          geom.translate(deltaX, deltaY);\n          geom.transform(projection, userProjection);\n        } else {\n          geom.translate(deltaX, deltaY);\n        }\n        feature.setGeometry(geom);\n      });\n\n      this.lastCoordinate_ = newCoordinate;\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATING,\n          features,\n          newCoordinate,\n          this.startCoordinate_,\n          event,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Handle pointer move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @override\n   */\n  handleMoveEvent(event) {\n    const elem = event.map.getViewport();\n\n    // Change the cursor to grab/grabbing if hovering any of the features managed\n    // by the interaction\n    if (this.featuresAtPixel_(event.pixel, event.map)) {\n      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\n      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\n    } else {\n      elem.classList.remove('ol-grab', 'ol-grabbing');\n    }\n  }\n\n  /**\n   * Tests to see if the given coordinates intersects any of our selected\n   * features.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel coordinate to test for intersection.\n   * @param {import(\"../Map.js\").default} map Map to test the intersection on.\n   * @return {Feature} Returns the feature found at the specified pixel\n   * coordinates.\n   * @private\n   */\n  featuresAtPixel_(pixel, map) {\n    return map.forEachFeatureAtPixel(\n      pixel,\n      (feature, layer) => {\n        if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n          return undefined;\n        }\n        if (this.features_ && !this.features_.getArray().includes(feature)) {\n          return undefined;\n        }\n        return feature;\n      },\n      {\n        layerFilter: this.layerFilter_,\n        hitTolerance: this.hitTolerance_,\n      },\n    );\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   * @override\n   */\n  setMap(map) {\n    const oldMap = this.getMap();\n    super.setMap(map);\n    this.updateState_(oldMap);\n  }\n\n  /**\n   * @private\n   */\n  handleActiveChanged_() {\n    this.updateState_(null);\n  }\n\n  /**\n   * @param {import(\"../Map.js\").default} oldMap Old map.\n   * @private\n   */\n  updateState_(oldMap) {\n    let map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      map = map || oldMap;\n      if (map) {\n        const elem = map.getViewport();\n        elem.classList.remove('ol-grab', 'ol-grabbing');\n      }\n    }\n  }\n}\n\nexport default Translate;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,UAAU,MAAM,kBAAkB;AACzC,OAAOC,KAAK,MAAM,oBAAoB;AACtC,OAAOC,OAAO,MAAM,eAAe;AACnC,OAAOC,mBAAmB,MAAM,eAAe;AAC/C,OAAOC,kBAAkB,MAAM,cAAc;AAC7C,SAAQC,IAAI,QAAO,iBAAiB;AACpC,SAAQC,MAAM,QAAO,wBAAwB;AAC7C,SAAQC,kBAAkB,EAAEC,iBAAiB,QAAO,YAAY;;AAEhE;AACA;AACA;AACA,MAAMC,kBAAkB,GAAG;EACzB;AACF;AACA;AACA;AACA;EACEC,cAAc,EAAE,gBAAgB;EAChC;AACF;AACA;AACA;AACA;EACEC,WAAW,EAAE,aAAa;EAC1B;AACF;AACA;AACA;AACA;EACEC,YAAY,EAAE;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,SAASZ,KAAK,CAAC;EACxC;AACF;AACA;AACA;AACA;AACA;AACA;EACEa,WAAWA,CAACC,IAAI,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,eAAe,EAAEC,eAAe,EAAE;IACxE,KAAK,CAACJ,IAAI,CAAC;;IAEX;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,QAAQ,GAAGA,QAAQ;;IAExB;AACJ;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,UAAU,GAAGA,UAAU;;IAE5B;AACJ;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,eAAe,GAAGA,eAAe;;IAEtC;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,eAAe,GAAGA,eAAe;EACxC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,SAAShB,kBAAkB,CAAC;EACzC;AACF;AACA;EACEU,WAAWA,CAACO,OAAO,EAAE;IACnBA,OAAO,GAAGA,OAAO,GAAGA,OAAO,GAAG,CAAC,CAAC;IAEhC,KAAK,CAAC,6CAA+CA,OAAQ,CAAC;;IAE9D;AACJ;AACA;IACI,IAAI,CAACC,EAAE;;IAEP;AACJ;AACA;IACI,IAAI,CAACC,IAAI;;IAET;AACJ;AACA;IACI,IAAI,CAACC,EAAE;;IAEP;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,eAAe,GAAG,IAAI;;IAE3B;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,gBAAgB,GAAG,IAAI;;IAE5B;AACJ;AACA;AACA;IACI,IAAI,CAACC,SAAS,GAAGN,OAAO,CAACL,QAAQ,KAAKY,SAAS,GAAGP,OAAO,CAACL,QAAQ,GAAG,IAAI;;IAEzE;IACA,IAAIa,WAAW;IACf,IAAIR,OAAO,CAACS,MAAM,IAAI,CAAC,IAAI,CAACH,SAAS,EAAE;MACrC,IAAI,OAAON,OAAO,CAACS,MAAM,KAAK,UAAU,EAAE;QACxCD,WAAW,GAAGR,OAAO,CAACS,MAAM;MAC9B,CAAC,MAAM;QACL,MAAMA,MAAM,GAAGT,OAAO,CAACS,MAAM;QAC7BD,WAAW,GAAG,SAAAA,CAAUE,KAAK,EAAE;UAC7B,OAAOD,MAAM,CAACE,QAAQ,CAACD,KAAK,CAAC;QAC/B,CAAC;MACH;IACF,CAAC,MAAM;MACLF,WAAW,GAAGxB,IAAI;IACpB;;IAEA;AACJ;AACA;AACA;IACI,IAAI,CAAC4B,YAAY,GAAGJ,WAAW;;IAE/B;AACJ;AACA;AACA;IACI,IAAI,CAACK,OAAO,GAAGb,OAAO,CAACc,MAAM,IAAI,CAAC,IAAI,CAACR,SAAS,GAAGN,OAAO,CAACc,MAAM,GAAG9B,IAAI;;IAExE;AACJ;AACA;AACA;IACI,IAAI,CAAC+B,aAAa,GAAGf,OAAO,CAACgB,YAAY,GAAGhB,OAAO,CAACgB,YAAY,GAAG,CAAC;;IAEpE;AACJ;AACA;AACA;IACI,IAAI,CAACC,UAAU,GAAGjB,OAAO,CAACkB,SAAS,GAAGlB,OAAO,CAACkB,SAAS,GAAGjC,MAAM;;IAEhE;AACJ;AACA;AACA;IACI,IAAI,CAACkC,YAAY,GAAG,IAAI;IAExB,IAAI,CAACC,iBAAiB,CACpBtC,mBAAmB,CAACuC,MAAM,EAC1B,IAAI,CAACC,oBACP,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,eAAeA,CAACC,KAAK,EAAE;IACrB,IAAI,CAACA,KAAK,CAACC,aAAa,IAAI,CAAC,IAAI,CAACR,UAAU,CAACO,KAAK,CAAC,EAAE;MACnD,OAAO,KAAK;IACd;IACA,IAAI,CAACL,YAAY,GAAG,IAAI,CAACO,gBAAgB,CAACF,KAAK,CAACG,KAAK,EAAEH,KAAK,CAACI,GAAG,CAAC;IACjE,IAAI,CAAC,IAAI,CAACxB,eAAe,IAAI,IAAI,CAACe,YAAY,EAAE;MAC9C,IAAI,CAACd,gBAAgB,GAAGmB,KAAK,CAAC5B,UAAU;MACxC,IAAI,CAACQ,eAAe,GAAGoB,KAAK,CAAC5B,UAAU;MACvC,IAAI,CAACiC,eAAe,CAACL,KAAK,CAAC;MAE3B,MAAM7B,QAAQ,GAAG,IAAI,CAACW,SAAS,IAAI,IAAI3B,UAAU,CAAC,CAAC,IAAI,CAACwC,YAAY,CAAC,CAAC;MAEtE,IAAI,CAACW,aAAa,CAChB,IAAItC,cAAc,CAChBJ,kBAAkB,CAACC,cAAc,EACjCM,QAAQ,EACR6B,KAAK,CAAC5B,UAAU,EAChB,IAAI,CAACS,gBAAgB,EACrBmB,KACF,CACF,CAAC;MACD,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEO,aAAaA,CAACP,KAAK,EAAE;IACnB,IAAI,IAAI,CAACpB,eAAe,EAAE;MACxB,IAAI,CAACA,eAAe,GAAG,IAAI;MAC3B,IAAI,CAACyB,eAAe,CAACL,KAAK,CAAC;MAE3B,MAAM7B,QAAQ,GAAG,IAAI,CAACW,SAAS,IAAI,IAAI3B,UAAU,CAAC,CAAC,IAAI,CAACwC,YAAY,CAAC,CAAC;MAEtE,IAAI,CAACW,aAAa,CAChB,IAAItC,cAAc,CAChBJ,kBAAkB,CAACG,YAAY,EAC/BI,QAAQ,EACR6B,KAAK,CAAC5B,UAAU,EAChB,IAAI,CAACS,gBAAgB,EACrBmB,KACF,CACF,CAAC;MACD;MACA,IAAI,CAACnB,gBAAgB,GAAG,IAAI;MAC5B,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;EACE2B,eAAeA,CAACR,KAAK,EAAE;IACrB,IAAI,IAAI,CAACpB,eAAe,EAAE;MACxB,MAAM6B,aAAa,GAAGT,KAAK,CAAC5B,UAAU;MACtC,MAAMsC,UAAU,GAAGV,KAAK,CAACI,GAAG,CAACO,OAAO,CAAC,CAAC,CAACC,aAAa,CAAC,CAAC;MAEtD,MAAMC,iBAAiB,GAAGnD,kBAAkB,CAAC+C,aAAa,EAAEC,UAAU,CAAC;MACvE,MAAMI,kBAAkB,GAAGpD,kBAAkB,CAC3C,IAAI,CAACkB,eAAe,EACpB8B,UACF,CAAC;MACD,MAAMK,MAAM,GAAGF,iBAAiB,CAAC,CAAC,CAAC,GAAGC,kBAAkB,CAAC,CAAC,CAAC;MAC3D,MAAME,MAAM,GAAGH,iBAAiB,CAAC,CAAC,CAAC,GAAGC,kBAAkB,CAAC,CAAC,CAAC;MAE3D,MAAM3C,QAAQ,GAAG,IAAI,CAACW,SAAS,IAAI,IAAI3B,UAAU,CAAC,CAAC,IAAI,CAACwC,YAAY,CAAC,CAAC;MACtE,MAAMsB,cAAc,GAAGtD,iBAAiB,CAAC,CAAC;MAE1CQ,QAAQ,CAAC+C,OAAO,CAAC,UAAUC,OAAO,EAAE;QAClC,MAAMC,IAAI,GAAGD,OAAO,CAACE,WAAW,CAAC,CAAC;QAClC,IAAIJ,cAAc,EAAE;UAClBG,IAAI,CAACE,SAAS,CAACL,cAAc,EAAEP,UAAU,CAAC;UAC1CU,IAAI,CAACG,SAAS,CAACR,MAAM,EAAEC,MAAM,CAAC;UAC9BI,IAAI,CAACE,SAAS,CAACZ,UAAU,EAAEO,cAAc,CAAC;QAC5C,CAAC,MAAM;UACLG,IAAI,CAACG,SAAS,CAACR,MAAM,EAAEC,MAAM,CAAC;QAChC;QACAG,OAAO,CAACK,WAAW,CAACJ,IAAI,CAAC;MAC3B,CAAC,CAAC;MAEF,IAAI,CAACxC,eAAe,GAAG6B,aAAa;MAEpC,IAAI,CAACH,aAAa,CAChB,IAAItC,cAAc,CAChBJ,kBAAkB,CAACE,WAAW,EAC9BK,QAAQ,EACRsC,aAAa,EACb,IAAI,CAAC5B,gBAAgB,EACrBmB,KACF,CACF,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEK,eAAeA,CAACL,KAAK,EAAE;IACrB,MAAMyB,IAAI,GAAGzB,KAAK,CAACI,GAAG,CAACsB,WAAW,CAAC,CAAC;;IAEpC;IACA;IACA,IAAI,IAAI,CAACxB,gBAAgB,CAACF,KAAK,CAACG,KAAK,EAAEH,KAAK,CAACI,GAAG,CAAC,EAAE;MACjDqB,IAAI,CAACE,SAAS,CAACC,MAAM,CAAC,IAAI,CAAChD,eAAe,GAAG,SAAS,GAAG,aAAa,CAAC;MACvE6C,IAAI,CAACE,SAAS,CAACE,GAAG,CAAC,IAAI,CAACjD,eAAe,GAAG,aAAa,GAAG,SAAS,CAAC;IACtE,CAAC,MAAM;MACL6C,IAAI,CAACE,SAAS,CAACC,MAAM,CAAC,SAAS,EAAE,aAAa,CAAC;IACjD;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE1B,gBAAgBA,CAACC,KAAK,EAAEC,GAAG,EAAE;IAC3B,OAAOA,GAAG,CAAC0B,qBAAqB,CAC9B3B,KAAK,EACL,CAACgB,OAAO,EAAEjC,KAAK,KAAK;MAClB,IAAI,EAAEiC,OAAO,YAAY9D,OAAO,CAAC,IAAI,CAAC,IAAI,CAACgC,OAAO,CAAC8B,OAAO,EAAEjC,KAAK,CAAC,EAAE;QAClE,OAAOH,SAAS;MAClB;MACA,IAAI,IAAI,CAACD,SAAS,IAAI,CAAC,IAAI,CAACA,SAAS,CAACiD,QAAQ,CAAC,CAAC,CAAC5C,QAAQ,CAACgC,OAAO,CAAC,EAAE;QAClE,OAAOpC,SAAS;MAClB;MACA,OAAOoC,OAAO;IAChB,CAAC,EACD;MACEnC,WAAW,EAAE,IAAI,CAACI,YAAY;MAC9BI,YAAY,EAAE,IAAI,CAACD;IACrB,CACF,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;EACEyC,eAAeA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACzC,aAAa;EAC3B;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE0C,eAAeA,CAACzC,YAAY,EAAE;IAC5B,IAAI,CAACD,aAAa,GAAGC,YAAY;EACnC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE0C,MAAMA,CAAC9B,GAAG,EAAE;IACV,MAAM+B,MAAM,GAAG,IAAI,CAACC,MAAM,CAAC,CAAC;IAC5B,KAAK,CAACF,MAAM,CAAC9B,GAAG,CAAC;IACjB,IAAI,CAACiC,YAAY,CAACF,MAAM,CAAC;EAC3B;;EAEA;AACF;AACA;EACErC,oBAAoBA,CAAA,EAAG;IACrB,IAAI,CAACuC,YAAY,CAAC,IAAI,CAAC;EACzB;;EAEA;AACF;AACA;AACA;EACEA,YAAYA,CAACF,MAAM,EAAE;IACnB,IAAI/B,GAAG,GAAG,IAAI,CAACgC,MAAM,CAAC,CAAC;IACvB,MAAME,MAAM,GAAG,IAAI,CAACC,SAAS,CAAC,CAAC;IAC/B,IAAI,CAACnC,GAAG,IAAI,CAACkC,MAAM,EAAE;MACnBlC,GAAG,GAAGA,GAAG,IAAI+B,MAAM;MACnB,IAAI/B,GAAG,EAAE;QACP,MAAMqB,IAAI,GAAGrB,GAAG,CAACsB,WAAW,CAAC,CAAC;QAC9BD,IAAI,CAACE,SAAS,CAACC,MAAM,CAAC,SAAS,EAAE,aAAa,CAAC;MACjD;IACF;EACF;AACF;AAEA,eAAerD,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}