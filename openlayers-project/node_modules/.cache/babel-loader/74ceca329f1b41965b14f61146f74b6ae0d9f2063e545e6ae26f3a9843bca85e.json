{"ast":null,"code":"/**\n * @module ol/source/VectorTile\n */\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport { DEFAULT_MAX_ZOOM } from '../tilegrid/common.js';\nimport { buffer as bufferExtent, getIntersection, intersects } from '../extent.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { isEmpty } from '../obj.js';\nimport { loadFeaturesXhr } from '../featureloader.js';\nimport { toSize } from '../size.js';\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default<FeatureType>} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate tiles.\n * Default is {@link module:ol/VectorTile~VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n */\nclass VectorTile extends UrlTile {\n  /**\n   * @param {!Options<FeatureType>} options Vector tile options.\n   */\n  constructor(options) {\n    const projection = options.projection || 'EPSG:3857';\n    const extent = options.extent || extentFromProjection(projection);\n    const tileGrid = options.tileGrid || createXYZ({\n      extent: extent,\n      maxResolution: options.maxResolution,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      interpolate: true,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection\n    });\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default<FeatureType>|null}\n     */\n    this.format_ = options.format ? options.format : null;\n\n    /**\n     * @type {Object<string, Array<string>>}\n     * @private\n     */\n    this.tileKeysBySourceTileUrl_ = {};\n\n    /**\n     @type {Object<string, Tile<FeatureType>>}\n     */\n    this.sourceTiles_ = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGrids_ = {};\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector render tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n  getSourceTiles(pixelRatio, projection, tile) {\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n      const urlTileCoord = tile.wrappedTileCoord;\n      const tileGrid = this.getTileGridForProjection(projection);\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      const z = urlTileCoord[0];\n      const resolution = tileGrid.getResolution(z);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(extent, -resolution, extent);\n      const sourceTileGrid = this.tileGrid;\n      const sourceExtent = sourceTileGrid.getExtent();\n      if (sourceExtent) {\n        getIntersection(extent, sourceExtent, extent);\n      }\n      const sourceZ = sourceTileGrid.getZForResolution(resolution, this.zDirection);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, sourceTileCoord => {\n        const tileUrl = this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n        if (!this.sourceTiles_[tileUrl]) {\n          this.sourceTiles_[tileUrl] = new this.tileClass(sourceTileCoord, tileUrl ? TileState.IDLE : TileState.EMPTY, tileUrl, this.format_, this.tileLoadFunction);\n        }\n        const sourceTile = this.sourceTiles_[tileUrl];\n        tile.sourceTiles.push(sourceTile);\n        if (!this.tileKeysBySourceTileUrl_[tileUrl]) {\n          this.tileKeysBySourceTileUrl_[tileUrl] = [];\n        }\n        this.tileKeysBySourceTileUrl_[tileUrl].push(tile.getKey());\n        const sourceTileState = sourceTile.getState();\n        if (sourceTileState < TileState.LOADED) {\n          const listenChange = event => {\n            this.handleTileChange(event);\n            const state = sourceTile.getState();\n            if (state === TileState.LOADED || state === TileState.ERROR) {\n              const sourceTileKey = sourceTile.getKey();\n              if (sourceTileKey in tile.errorTileKeys) {\n                if (sourceTile.getState() === TileState.LOADED) {\n                  delete tile.errorTileKeys[sourceTileKey];\n                }\n              } else {\n                tile.loadingSourceTiles--;\n              }\n              if (state === TileState.ERROR) {\n                tile.errorTileKeys[sourceTileKey] = true;\n              } else {\n                sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n              }\n              if (tile.loadingSourceTiles === 0) {\n                tile.setState(isEmpty(tile.errorTileKeys) ? TileState.LOADED : TileState.ERROR);\n              }\n            }\n          };\n          sourceTile.addEventListener(EventType.CHANGE, listenChange);\n          tile.loadingSourceTiles++;\n        }\n        if (sourceTileState === TileState.IDLE) {\n          sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n          sourceTile.projection = projection;\n          sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);\n          sourceTile.load();\n        }\n      });\n      if (!tile.loadingSourceTiles) {\n        tile.setState(tile.sourceTiles.some(sourceTile => sourceTile.getState() === TileState.ERROR) ? TileState.ERROR : TileState.LOADED);\n      }\n    }\n    return tile.sourceTiles;\n  }\n\n  /**\n   * @param {VectorRenderTile} tile Vector render tile.\n   */\n  removeSourceTiles(tile) {\n    const sourceTiles = tile.sourceTiles;\n    for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n      const sourceTileUrl = sourceTiles[i].getTileUrl();\n      const tileKey = this.getKey();\n      if (!this.tileKeysBySourceTileUrl_[sourceTileUrl]) {\n        return;\n      }\n      const index = this.tileKeysBySourceTileUrl_[sourceTileUrl][tileKey];\n      if (index === -1) {\n        continue;\n      }\n      this.tileKeysBySourceTileUrl_[sourceTileUrl].splice(index, 1);\n      if (this.tileKeysBySourceTileUrl_[sourceTileUrl].length === 0) {\n        delete this.tileKeysBySourceTileUrl_[sourceTileUrl];\n        delete this.sourceTiles_[sourceTileUrl];\n      }\n    }\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoord = [z, x, y];\n    let urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    const sourceExtent = this.getTileGrid().getExtent();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (urlTileCoord && sourceExtent) {\n      const tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n    let empty = true;\n    if (urlTileCoord !== null) {\n      const sourceTileGrid = this.tileGrid;\n      const resolution = tileGrid.getResolution(z);\n      const sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, sourceTileCoord => {\n        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      });\n    }\n    const newTile = new VectorRenderTile(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection), this.removeSourceTiles.bind(this));\n    newTile.key = this.getKey();\n    return newTile;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const code = projection.getCode();\n    let tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      const sourceTileGrid = this.tileGrid;\n      const resolutions = sourceTileGrid.getResolutions().slice();\n      const origins = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getOrigin(z);\n      });\n      const tileSizes = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getTileSize(z);\n      });\n      const length = DEFAULT_MAX_ZOOM + 1;\n      for (let z = resolutions.length; z < length; ++z) {\n        resolutions.push(resolutions[z - 1] / 2);\n        origins.push(origins[z - 1]);\n        tileSizes.push(tileSizes[z - 1]);\n      }\n      tileGrid = new TileGrid({\n        extent: sourceTileGrid.getExtent(),\n        origins: origins,\n        resolutions: resolutions,\n        tileSizes: tileSizes\n      });\n      this.tileGrids_[code] = tileGrid;\n    }\n    return tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   * @override\n   */\n  getTilePixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   * @override\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n  }\n}\nexport default VectorTile;\n\n/**\n * Sets the loader for a tile.\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @param {import(\"../VectorTile.js\").default<FeatureType>} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n  tile.setLoader(\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  function (extent, resolution, projection) {\n    loadFeaturesXhr(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));\n  });\n}","map":{"version":3,"names":["EventType","Tile","TileGrid","TileState","UrlTile","VectorRenderTile","DEFAULT_MAX_ZOOM","buffer","bufferExtent","getIntersection","intersects","createXYZ","extentFromProjection","isEmpty","loadFeaturesXhr","toSize","VectorTile","constructor","options","projection","extent","tileGrid","maxResolution","maxZoom","undefined","minZoom","tileSize","attributions","attributionsCollapsible","cacheSize","interpolate","state","tileLoadFunction","defaultLoadFunction","tileUrlFunction","url","urls","wrapX","transition","zDirection","format_","format","tileKeysBySourceTileUrl_","sourceTiles_","overlaps_","overlaps","tileClass","tileGrids_","getOverlaps","getSourceTiles","pixelRatio","tile","getState","IDLE","setState","LOADING","urlTileCoord","wrappedTileCoord","getTileGridForProjection","getTileCoordExtent","z","resolution","getResolution","sourceTileGrid","sourceExtent","getExtent","sourceZ","getZForResolution","forEachTileCoord","sourceTileCoord","tileUrl","EMPTY","sourceTile","sourceTiles","push","getKey","sourceTileState","LOADED","listenChange","event","handleTileChange","ERROR","sourceTileKey","errorTileKeys","loadingSourceTiles","removeEventListener","CHANGE","addEventListener","load","some","removeSourceTiles","i","ii","length","sourceTileUrl","getTileUrl","tileKey","index","splice","getTile","x","y","tileCoord","getTileCoordForTileUrlFunction","getTileGrid","tileExtent","empty","newTile","bind","key","code","getCode","resolutions","getResolutions","slice","origins","map","getOrigin","tileSizes","getTileSize","getTilePixelRatio","getTilePixelSize","tmpSize","Math","round","setLoader","getFormat","onLoad","onError"],"sources":["C:/Users/hasan/webproj/openlayers-project/node_modules/ol/source/VectorTile.js"],"sourcesContent":["/**\n * @module ol/source/VectorTile\n */\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport {DEFAULT_MAX_ZOOM} from '../tilegrid/common.js';\nimport {\n  buffer as bufferExtent,\n  getIntersection,\n  intersects,\n} from '../extent.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {isEmpty} from '../obj.js';\nimport {loadFeaturesXhr} from '../featureloader.js';\nimport {toSize} from '../size.js';\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default<FeatureType>} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate tiles.\n * Default is {@link module:ol/VectorTile~VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n */\nclass VectorTile extends UrlTile {\n  /**\n   * @param {!Options<FeatureType>} options Vector tile options.\n   */\n  constructor(options) {\n    const projection = options.projection || 'EPSG:3857';\n\n    const extent = options.extent || extentFromProjection(projection);\n\n    const tileGrid =\n      options.tileGrid ||\n      createXYZ({\n        extent: extent,\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize || 512,\n      });\n\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      interpolate: true,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default<FeatureType>|null}\n     */\n    this.format_ = options.format ? options.format : null;\n\n    /**\n     * @type {Object<string, Array<string>>}\n     * @private\n     */\n    this.tileKeysBySourceTileUrl_ = {};\n\n    /**\n     @type {Object<string, Tile<FeatureType>>}\n     */\n    this.sourceTiles_ = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGrids_ = {};\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector render tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n  getSourceTiles(pixelRatio, projection, tile) {\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n      const urlTileCoord = tile.wrappedTileCoord;\n      const tileGrid = this.getTileGridForProjection(projection);\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      const z = urlTileCoord[0];\n      const resolution = tileGrid.getResolution(z);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(extent, -resolution, extent);\n      const sourceTileGrid = this.tileGrid;\n      const sourceExtent = sourceTileGrid.getExtent();\n      if (sourceExtent) {\n        getIntersection(extent, sourceExtent, extent);\n      }\n      const sourceZ = sourceTileGrid.getZForResolution(\n        resolution,\n        this.zDirection,\n      );\n\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, (sourceTileCoord) => {\n        const tileUrl = this.tileUrlFunction(\n          sourceTileCoord,\n          pixelRatio,\n          projection,\n        );\n        if (!this.sourceTiles_[tileUrl]) {\n          this.sourceTiles_[tileUrl] = new this.tileClass(\n            sourceTileCoord,\n            tileUrl ? TileState.IDLE : TileState.EMPTY,\n            tileUrl,\n            this.format_,\n            this.tileLoadFunction,\n          );\n        }\n        const sourceTile = this.sourceTiles_[tileUrl];\n        tile.sourceTiles.push(sourceTile);\n        if (!this.tileKeysBySourceTileUrl_[tileUrl]) {\n          this.tileKeysBySourceTileUrl_[tileUrl] = [];\n        }\n        this.tileKeysBySourceTileUrl_[tileUrl].push(tile.getKey());\n        const sourceTileState = sourceTile.getState();\n        if (sourceTileState < TileState.LOADED) {\n          const listenChange = (event) => {\n            this.handleTileChange(event);\n            const state = sourceTile.getState();\n            if (state === TileState.LOADED || state === TileState.ERROR) {\n              const sourceTileKey = sourceTile.getKey();\n              if (sourceTileKey in tile.errorTileKeys) {\n                if (sourceTile.getState() === TileState.LOADED) {\n                  delete tile.errorTileKeys[sourceTileKey];\n                }\n              } else {\n                tile.loadingSourceTiles--;\n              }\n              if (state === TileState.ERROR) {\n                tile.errorTileKeys[sourceTileKey] = true;\n              } else {\n                sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n              }\n              if (tile.loadingSourceTiles === 0) {\n                tile.setState(\n                  isEmpty(tile.errorTileKeys)\n                    ? TileState.LOADED\n                    : TileState.ERROR,\n                );\n              }\n            }\n          };\n          sourceTile.addEventListener(EventType.CHANGE, listenChange);\n          tile.loadingSourceTiles++;\n        }\n        if (sourceTileState === TileState.IDLE) {\n          sourceTile.extent =\n            sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n          sourceTile.projection = projection;\n          sourceTile.resolution = sourceTileGrid.getResolution(\n            sourceTileCoord[0],\n          );\n          sourceTile.load();\n        }\n      });\n      if (!tile.loadingSourceTiles) {\n        tile.setState(\n          tile.sourceTiles.some(\n            (sourceTile) => sourceTile.getState() === TileState.ERROR,\n          )\n            ? TileState.ERROR\n            : TileState.LOADED,\n        );\n      }\n    }\n\n    return tile.sourceTiles;\n  }\n\n  /**\n   * @param {VectorRenderTile} tile Vector render tile.\n   */\n  removeSourceTiles(tile) {\n    const sourceTiles = tile.sourceTiles;\n    for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n      const sourceTileUrl = sourceTiles[i].getTileUrl();\n      const tileKey = this.getKey();\n      if (!this.tileKeysBySourceTileUrl_[sourceTileUrl]) {\n        return;\n      }\n      const index = this.tileKeysBySourceTileUrl_[sourceTileUrl][tileKey];\n      if (index === -1) {\n        continue;\n      }\n      this.tileKeysBySourceTileUrl_[sourceTileUrl].splice(index, 1);\n      if (this.tileKeysBySourceTileUrl_[sourceTileUrl].length === 0) {\n        delete this.tileKeysBySourceTileUrl_[sourceTileUrl];\n        delete this.sourceTiles_[sourceTileUrl];\n      }\n    }\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoord = [z, x, y];\n    let urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection,\n    );\n    const sourceExtent = this.getTileGrid().getExtent();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (urlTileCoord && sourceExtent) {\n      const tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n    let empty = true;\n    if (urlTileCoord !== null) {\n      const sourceTileGrid = this.tileGrid;\n      const resolution = tileGrid.getResolution(z);\n      const sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, (sourceTileCoord) => {\n        empty =\n          empty &&\n          !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      });\n    }\n    const newTile = new VectorRenderTile(\n      tileCoord,\n      empty ? TileState.EMPTY : TileState.IDLE,\n      urlTileCoord,\n      this.getSourceTiles.bind(this, pixelRatio, projection),\n      this.removeSourceTiles.bind(this),\n    );\n    newTile.key = this.getKey();\n    return newTile;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const code = projection.getCode();\n    let tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      const sourceTileGrid = this.tileGrid;\n      const resolutions = sourceTileGrid.getResolutions().slice();\n      const origins = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getOrigin(z);\n      });\n      const tileSizes = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getTileSize(z);\n      });\n      const length = DEFAULT_MAX_ZOOM + 1;\n      for (let z = resolutions.length; z < length; ++z) {\n        resolutions.push(resolutions[z - 1] / 2);\n        origins.push(origins[z - 1]);\n        tileSizes.push(tileSizes[z - 1]);\n      }\n      tileGrid = new TileGrid({\n        extent: sourceTileGrid.getExtent(),\n        origins: origins,\n        resolutions: resolutions,\n        tileSizes: tileSizes,\n      });\n      this.tileGrids_[code] = tileGrid;\n    }\n    return tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   * @override\n   */\n  getTilePixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   * @override\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [\n      Math.round(tileSize[0] * pixelRatio),\n      Math.round(tileSize[1] * pixelRatio),\n    ];\n  }\n}\n\nexport default VectorTile;\n\n/**\n * Sets the loader for a tile.\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../render/Feature.js\").default]\n * @param {import(\"../VectorTile.js\").default<FeatureType>} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n  tile.setLoader(\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    function (extent, resolution, projection) {\n      loadFeaturesXhr(\n        url,\n        tile.getFormat(),\n        extent,\n        resolution,\n        projection,\n        tile.onLoad.bind(tile),\n        tile.onError.bind(tile),\n      );\n    },\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}